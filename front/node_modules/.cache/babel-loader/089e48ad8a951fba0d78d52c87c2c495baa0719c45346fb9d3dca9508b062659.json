{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useCallback, useRef } from 'react';\n\n// WebSocket 서버 URL\nconst WS_URL = 'ws://218.156.126.186:8000/ws';\n\n// useWebSocket 커스텀 훅: WebSocket 연결 및 관련 기능을 관리\nexport function useWebSocket(user) {\n  _s();\n  // 상태 관리\n  const [socket, setSocket] = useState(null); // WebSocket 인스턴스\n  const [userCount, setUserCount] = useState(0); // 현재 접속 사용자 수\n  const [showSessionExpiredModal, setShowSessionExpiredModal] = useState(false); // 세션 만료 모달 표시 여부\n  const [chatBanTimeLeft, setChatBanTimeLeft] = useState(0); // 채팅 금지 남은 시간\n\n  // ref를 사용한 값 관리\n  const reconnectAttempt = useRef(0); // 재연결 시도 횟수\n  const timeoutId = useRef(null); // 재연결 타이머 ID\n\n  // WebSocket 설정 및 연결 함수\n  const setupWebSocket = useCallback(() => {\n    if (!user) return;\n    const newSocket = new WebSocket(`${WS_URL}/${user.userId}`);\n\n    // WebSocket 연결 성공 시\n    newSocket.onopen = () => {\n      console.log('WebSocket Connected');\n      setSocket(newSocket);\n      reconnectAttempt.current = 0;\n    };\n\n    // 서버로부터 메시지 수신 시\n    newSocket.onmessage = event => {\n      const data = JSON.parse(event.data);\n      if (data.type === 'user_count') {\n        setUserCount(data.count);\n      } else if (data.type === 'session_expired') {\n        setShowSessionExpiredModal(true);\n      } else if (data.type === 'chat_banned') {\n        setChatBanTimeLeft(data.time_left);\n      }\n    };\n\n    // WebSocket 연결 종료 시\n    newSocket.onclose = event => {\n      if (event.code !== 1000) {\n        // 1000은 정상 종료 코드\n        console.log('WebSocket Disconnected');\n        // 지수 백오프 및 지터를 사용한 재연결 로직\n        const timeout = Math.min(1000 * 2 ** reconnectAttempt.current, 30000);\n        const jitter = Math.random() * 1000;\n        console.log(`Attempting to reconnect in ${timeout + jitter}ms...`);\n        timeoutId.current = setTimeout(() => {\n          reconnectAttempt.current++;\n          setupWebSocket();\n        }, timeout + jitter);\n      }\n    };\n\n    // WebSocket 에러 발생 시\n    newSocket.onerror = error => {\n      console.error('WebSocket Error:', error);\n    };\n  }, [user]);\n\n  // 사용자 정보가 변경될 때 WebSocket 연결 설정\n  useEffect(() => {\n    if (user) {\n      setupWebSocket();\n    }\n    return () => {\n      if (socket) {\n        socket.close(1000, \"Intentional disconnect\");\n      }\n      if (timeoutId.current) {\n        clearTimeout(timeoutId.current);\n      }\n    };\n  }, [user, setupWebSocket]);\n\n  // 채팅 금지 시간 카운트다운\n  useEffect(() => {\n    if (chatBanTimeLeft > 0) {\n      const timer = setInterval(() => {\n        setChatBanTimeLeft(prev => Math.max(0, prev - 1));\n      }, 1000);\n      return () => clearInterval(timer);\n    }\n  }, [chatBanTimeLeft]);\n\n  // 메시지 전송 함수\n  const sendMessage = useCallback(messageObj => {\n    if (socket && socket.readyState === WebSocket.OPEN) {\n      socket.send(JSON.stringify(messageObj));\n    } else {\n      console.error('WebSocket is not connected');\n    }\n  }, [socket]);\n\n  // 훅에서 반환하는 값들\n  return {\n    socket,\n    userCount,\n    showSessionExpiredModal,\n    setShowSessionExpiredModal,\n    chatBanTimeLeft,\n    sendMessage\n  };\n}\n_s(useWebSocket, \"NPmVav9bIv7ZCysbKvgMAH9PoUI=\");","map":{"version":3,"names":["useState","useEffect","useCallback","useRef","WS_URL","useWebSocket","user","_s","socket","setSocket","userCount","setUserCount","showSessionExpiredModal","setShowSessionExpiredModal","chatBanTimeLeft","setChatBanTimeLeft","reconnectAttempt","timeoutId","setupWebSocket","newSocket","WebSocket","userId","onopen","console","log","current","onmessage","event","data","JSON","parse","type","count","time_left","onclose","code","timeout","Math","min","jitter","random","setTimeout","onerror","error","close","clearTimeout","timer","setInterval","prev","max","clearInterval","sendMessage","messageObj","readyState","OPEN","send","stringify"],"sources":["/home/work/chat/front/src/hooks/useWebSocket.js"],"sourcesContent":["import { useState, useEffect, useCallback, useRef } from 'react';\n\n// WebSocket 서버 URL\nconst WS_URL = 'ws://218.156.126.186:8000/ws';\n\n// useWebSocket 커스텀 훅: WebSocket 연결 및 관련 기능을 관리\nexport function useWebSocket(user) {\n  // 상태 관리\n  const [socket, setSocket] = useState(null);  // WebSocket 인스턴스\n  const [userCount, setUserCount] = useState(0);  // 현재 접속 사용자 수\n  const [showSessionExpiredModal, setShowSessionExpiredModal] = useState(false);  // 세션 만료 모달 표시 여부\n  const [chatBanTimeLeft, setChatBanTimeLeft] = useState(0);  // 채팅 금지 남은 시간\n\n  // ref를 사용한 값 관리\n  const reconnectAttempt = useRef(0);  // 재연결 시도 횟수\n  const timeoutId = useRef(null);  // 재연결 타이머 ID\n\n  // WebSocket 설정 및 연결 함수\n  const setupWebSocket = useCallback(() => {\n    if (!user) return;\n\n    const newSocket = new WebSocket(`${WS_URL}/${user.userId}`);\n\n    // WebSocket 연결 성공 시\n    newSocket.onopen = () => {\n      console.log('WebSocket Connected');\n      setSocket(newSocket);\n      reconnectAttempt.current = 0;\n    };\n\n    // 서버로부터 메시지 수신 시\n    newSocket.onmessage = (event) => {\n      const data = JSON.parse(event.data);\n      if (data.type === 'user_count') {\n        setUserCount(data.count);\n      } else if (data.type === 'session_expired') {\n        setShowSessionExpiredModal(true);\n      } else if (data.type === 'chat_banned') {\n        setChatBanTimeLeft(data.time_left);\n      }\n    };\n\n    // WebSocket 연결 종료 시\n    newSocket.onclose = (event) => {\n      if (event.code !== 1000) {  // 1000은 정상 종료 코드\n        console.log('WebSocket Disconnected');\n        // 지수 백오프 및 지터를 사용한 재연결 로직\n        const timeout = Math.min(1000 * (2 ** reconnectAttempt.current), 30000);\n        const jitter = Math.random() * 1000;\n        console.log(`Attempting to reconnect in ${timeout + jitter}ms...`);\n        \n        timeoutId.current = setTimeout(() => {\n          reconnectAttempt.current++;\n          setupWebSocket();\n        }, timeout + jitter);\n      }\n    };\n\n    // WebSocket 에러 발생 시\n    newSocket.onerror = (error) => {\n      console.error('WebSocket Error:', error);\n    };\n  }, [user]);\n\n  // 사용자 정보가 변경될 때 WebSocket 연결 설정\n  useEffect(() => {\n    if (user) {\n      setupWebSocket();\n    }\n    return () => {\n      if (socket) {\n        socket.close(1000, \"Intentional disconnect\");\n      }\n      if (timeoutId.current) {\n        clearTimeout(timeoutId.current);\n      }\n    };\n  }, [user, setupWebSocket]);\n\n  // 채팅 금지 시간 카운트다운\n  useEffect(() => {\n    if (chatBanTimeLeft > 0) {\n      const timer = setInterval(() => {\n        setChatBanTimeLeft((prev) => Math.max(0, prev - 1));\n      }, 1000);\n      return () => clearInterval(timer);\n    }\n  }, [chatBanTimeLeft]);\n\n  // 메시지 전송 함수\n  const sendMessage = useCallback((messageObj) => {\n    if (socket && socket.readyState === WebSocket.OPEN) {\n      socket.send(JSON.stringify(messageObj));\n    } else {\n      console.error('WebSocket is not connected');\n    }\n  }, [socket]);\n\n  // 훅에서 반환하는 값들\n  return {\n    socket,\n    userCount,\n    showSessionExpiredModal,\n    setShowSessionExpiredModal,\n    chatBanTimeLeft,\n    sendMessage\n  };\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}